# -*- coding: utf-8 -*-
"""rubric IFMS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Vsw4D59zPaUO3XOawir-lTMPtB7MAdQY
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df_g = pd.read_csv("Rubric IFMS.csv")

df = pd.concat([df_g], ignore_index=True)
df

desc = df.groupby("group")[["correction","design","style","total"]].agg(
    ["mean","median","std","min","max"]
).round(2)

desc

desc_all = df[["correction","design","style","total"]].agg(
    ["mean","median","std","min","max"]
).round(2)

desc_all

df_long = df.melt(
    id_vars=["participant","group","rater","code"],
    value_vars=["correction","design","style","total"],
    var_name="criterion",
    value_name="score"
)

df_long.head()

import numpy as np
import matplotlib.pyplot as plt

# ===============================
# 1) Conversão das notas (0–3) para Likert
# ===============================

def convert_score_to_likert(x):
    """
    Converte a nota (0–3) da rubrica em uma categoria Likert.
    Ajuste os rótulos se quiser outro texto.
    """
    if x == 0:
        return "Totally disagree"
    if x == 1:
        return "Disagree"
    if x == 2:
        return "Agree"
    return "Totally agree"  # x == 3


# Dicionário: nome "bonito" do critério -> nome da coluna no df
# Ajuste aqui se suas colunas tiverem outros nomes
criteria_cols = {
    "Correction": "correction",
    "Design/Structure": "design",
    "Style/Readability": "style",
}

# Cria colunas Likert separadas para cada critério
for crit_label, col_name in criteria_cols.items():
    df[f"{col_name}_likert"] = df[col_name].apply(convert_score_to_likert)

# ===============================
# 2) Função que desenha o gráfico Likert empilhado
# ===============================

def survey(results, category_names):
    """
    Desenha um gráfico de barras horizontais empilhadas
    a partir de um dicionário:
        results = { label_da_linha: array_de_contagens_por_categoria }
    """
    labels = list(results.keys())
    data = np.array(list(results.values()))
    data_cum = data.cumsum(axis=1)

    # cores para as categorias Likert (mesma ordem de category_names)
    category_colors = ['darkred', 'tomato', 'lightgreen', 'darkgreen']

    # altura dinâmica baseada no número de linhas
    fig_height = 0.6 * len(labels)
    fig, ax = plt.subplots(figsize=(10, fig_height))
    ax.invert_yaxis()  # primeiro label em cima

    for i, (colname, color) in enumerate(zip(category_names, category_colors)):
        widths = data[:, i]
        starts = data_cum[:, i] - widths
        ax.barh(labels, widths, left=starts, height=0.5,
                label=colname, color=color)
        xcenters = starts + widths / 2

        text_color = 'white' if color in ['darkred', 'darkgreen'] else 'black'
        for y, (x, c) in enumerate(zip(xcenters, widths)):
            if c > 0:
                ax.text(x, y, str(int(c)), ha='center', va='center', color=text_color)

    total = np.sum(data, axis=1).max()
    ax.set_xlim(0, total)
    ax.set_xticks(np.linspace(0, total, 11))
    ax.set_xticklabels([f"{int((i/10)*100)}%" for i in range(11)])
    ax.grid(axis='x', color='gray', alpha=0.5, linestyle='dashed', linewidth=0.7)

    return fig, ax

# ===============================
# 3) Monta os dados para o gráfico
# ===============================

order = [
    "Totally disagree",
    "Disagree",
    "Agree",
    "Totally agree"
]

category_names = order

results = {
    "Correction":        df["correction_likert"].value_counts().reindex(order, fill_value=0).values,
    "Design/Structure":  df["design_likert"].value_counts().reindex(order, fill_value=0).values,
    "Style/Readability": df["style_likert"].value_counts().reindex(order, fill_value=0).values,
}


# ===============================
# 4) Gera o gráfico final
# ===============================

# ===============================
# 4) Gera o gráfico final
# ===============================

fig, ax = survey(results, category_names)

# 1. Ajuste o segundo valor (1.4) para subir ou descer a legenda
# 1.0 é o topo do gráfico. 1.4 coloca ela bem acima.
ax.legend(
    ncol=len(category_names),
    bbox_to_anchor=(0.5, 1.4),
    loc='upper center',
    fontsize=9,
    fancybox=True
)

# 2. O 'top=0.75' reserva espaço em branco no topo da figura para a legenda.
# Diminua esse valor (ex: 0.6) se a legenda ainda estiver cortada ou próxima.
plt.subplots_adjust(top=0.75)

plt.show()

# Critérios
criteria = ["correction", "design", "style", "total"]
stats = ["mean", "median", "std", "min", "max"]

# Função para gerar tabela de um grupo
def descriptive_table(group_number):
    df_group = df[df.group == group_number]
    table = df_group[criteria].agg(stats).round(2)
    return table

# Gerar tabelas separadas
table_g1 = descriptive_table(1)
table_g2 = descriptive_table(2)

table_g1, table_g2

plt.figure(figsize=(10,6))
sns.boxplot(
    data=df_long,
    x="criterion",
    y="score",
)
plt.xlabel("Criterion")
plt.ylabel("Score")
plt.show()